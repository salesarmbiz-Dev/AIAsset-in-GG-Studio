import { supabase } from './supabase';
import { Asset, SubscriptionTier, GenerationResult } from '../types';

// Mock Quotas
const TIER_LIMITS = {
  free: 2,
  member: 10,
  pro: 9999
};

export const generateAssetOutput = async (
  asset: Asset,
  fillValues: Record<string, any>,
  builtPrompt: string,
  userId: string | undefined,
  userTier: SubscriptionTier,
  remixSourceId?: string
): Promise<GenerationResult> => {
  if (!userId) return { success: false, error: "Login required" };

  // 1. Check Rate Limit (Mock)
  const today = new Date().toISOString().split('T')[0];
  const { count, error: countError } = await supabase
    .from('asset_generation_usage')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId)
    .gte('created_at', today);

  if ((count || 0) >= TIER_LIMITS[userTier]) {
    return { success: false, limitReached: true, error: `Daily limit reached for ${userTier}` };
  }

  // 2. Simulate AI Generation (Network Delay)
  await new Promise(resolve => setTimeout(resolve, 2500));

  // 3. Mock Output Logic based on Asset Type
  let mockOutput = `[AI GENERATED CONTENT for ${asset.title}]\n\n`;
  mockOutput += `Based on: ${builtPrompt.substring(0, 100)}...\n\n`;
  
  if (asset.tag === 'Planner') {
    mockOutput += `ðŸ“… **Campaign Plan**\n- Week 1: Teaser\n- Week 2: Launch\n- Week 3: Sustain\n\nðŸ’° Budget Allocation: 40/30/30`;
  } else if (asset.tag === 'Converter') {
    mockOutput += `âœ¨ **Converted Content**\n\nHere is your content optimized for the selected platform(s).\n\n#Hashtags #Content #Growth`;
  } else {
    mockOutput += `âœ… **Result**\n\nThis is a high-quality simulated response generated by the AI engine based on your inputs.`;
  }

  // 4. Record Usage
  const { data: usageData, error: usageError } = await supabase
    .from('asset_generation_usage')
    .insert([{
      asset_id: asset.id,
      user_id: userId,
      fill_values: fillValues,
      generated_output: mockOutput,
      remix_source_id: remixSourceId || null
    }])
    .select()
    .single();

  if (usageError) {
    console.error("Usage record error", usageError);
    // Proceed anyway as user experience shouldn't break on stats error
  }

  return { 
    success: true, 
    output: mockOutput,
    usageId: usageData?.id 
  };
};

// Helper to determine which field should receive the Remix content
export const getRemixTargetField = (asset: Asset): string | null => {
  // Strategy: Find the first 'Custom' or 'Template' field that looks like a main input
  // Priority: fields named 'content', 'input', 'text', 'original'
  
  const priorityKeywords = ['content', 'à¹€à¸™à¸·à¹‰à¸­à¸«à¸²', 'à¸•à¹‰à¸™à¸‰à¸šà¸±à¸š', 'à¸ªà¸´à¸™à¸„à¹‰à¸²', 'à¸‚à¹‰à¸­à¸¡à¸¹à¸¥'];
  
  // 1. Keyword search
  for (const field of asset.fields) {
    const lowerName = field.name.toLowerCase();
    const lowerLabel = field.label.toLowerCase();
    if (priorityKeywords.some(k => lowerName.includes(k) || lowerLabel.includes(k))) {
      if (field.type === 'Custom' || field.type === 'Template') {
        return field.name;
      }
    }
  }

  // 2. Fallback: First large input
  const largeInput = asset.fields.find(f => f.type === 'Template' || f.type === 'Custom');
  if (largeInput) return largeInput.name;

  return null;
};
